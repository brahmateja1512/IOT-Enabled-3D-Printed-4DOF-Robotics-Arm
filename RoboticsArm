#include <WiFi.h>
#include <WebServer.h>
#include <ESP32Servo.h>
#include <WebSocketsServer.h>
#include <PubSubClient.h>
#include <ArduinoJson.h>
#include "secrets.h"
#include "webpage.h"
#include "ik.h"

const int SERVO_PIN[4] = {13, 12, 14, 27};
const int NUM_JOINTS = 4;
const int ANGLE_MIN = 0;
const int ANGLE_MAX = 180;

WebServer server(80);
WebSocketsServer webSocket = WebSocketsServer(81);
WiFiClient espClient;
PubSubClient mqttClient(espClient);

Servo servos[NUM_JOINTS];
int currentAngles[NUM_JOINTS] = {90, 90, 90, 90};

const char* MQTT_CMD_TOPIC = "robotarm/commands";
const char* MQTT_STATE_TOPIC = "robotarm/state";
const char* MQTT_AVAILABILITY_TOPIC = "robotarm/availability";

void clampAngles() {
  for (int i = 0; i < NUM_JOINTS; ++i) {
    if (currentAngles[i] < ANGLE_MIN) currentAngles[i] = ANGLE_MIN;
    if (currentAngles[i] > ANGLE_MAX) currentAngles[i] = ANGLE_MAX;
  }
}

void applyAngles() {
  for (int i = 0; i < NUM_JOINTS; ++i) {
    servos[i].write(currentAngles[i]);
  }
}

String jsonState() {
  StaticJsonDocument<256> doc;
  for (int i = 0; i < NUM_JOINTS; ++i) {
    doc["j" + String(i+1)] = currentAngles[i];
  }
  String out;
  serializeJson(doc, out);
  return out;
}

void handleRoot() {
  server.send(200, "text/html", index_html);
}

void handleApiState() {
  server.send(200, "application/json", jsonState());
}

void handleMove() {
  bool changed = false;
  for (int i = 0; i < NUM_JOINTS; ++i) {
    String p = "j" + String(i+1);
    if (server.hasArg(p)) {
      int angle = server.arg(p).toInt();
      angle = constrain(angle, ANGLE_MIN, ANGLE_MAX);
      currentAngles[i] = angle;
      changed = true;
    }
  }
  if (changed) {
    clampAngles();
    applyAngles();
    server.send(200, "application/json", jsonState());
  } else {
    server.send(400, "application/json", "{\"status\":\"error\",\"message\":\"no joint parameters provided\"}");
  }
}

void handleNotFound(){
  String message = "Not found\n\n";
  message += "URI: ";
  message += server.uri();
  message += "\nMethod: ";
  message += (server.method() == HTTP_GET) ? "GET" : "OTHER";
  message += "\n";
  server.send(404, "text/plain", message);
}

void notifyWebClientsState() {
  String s = jsonState();
  webSocket.broadcastTXT(s);
}

void onWebSocketEvent(uint8_t num, WStype_t type, uint8_t * payload, size_t length) {
  if (type == WStype_TEXT) {
    StaticJsonDocument<256> doc;
    DeserializationError err = deserializeJson(doc, payload, length);
    if (err) {
      return;
    }
    const char* cmd = doc["cmd"] | "";
    if (strcmp(cmd, "move") == 0) {
      bool changed = false;
      for (int i = 0; i < NUM_JOINTS; ++i) {
        char key[4]; sprintf(key, "j%d", i+1);
        if (doc.containsKey(key)) {
          int angle = doc[key];
          currentAngles[i] = constrain(angle, ANGLE_MIN, ANGLE_MAX);
          changed = true;
        }
      }
      if (changed) { clampAngles(); applyAngles(); notifyWebClientsState(); if (mqttClient.connected()) mqttClient.publish(MQTT_STATE_TOPIC, jsonState().c_str()); }
    } else if (strcmp(cmd, "ik") == 0) {
      float x = doc["x"] | 0.0;
      float y = doc["y"] | 0.0;
      float z = doc["z"] | 0.0;
      float grip = doc["grip"] | 90.0;
      float outAngles[4];
      bool ok = computeIK(x, y, z, outAngles);
      if (ok) {
        currentAngles[0] = constrain((int)round(outAngles[0]), ANGLE_MIN, ANGLE_MAX);
        currentAngles[1] = constrain((int)round(outAngles[1]), ANGLE_MIN, ANGLE_MAX);
        currentAngles[2] = constrain((int)round(outAngles[2]), ANGLE_MIN, ANGLE_MAX);
        currentAngles[3] = constrain((int)round(grip), ANGLE_MIN, ANGLE_MAX);
        clampAngles();
        applyAngles();
        notifyWebClientsState();
        if (mqttClient.connected()) mqttClient.publish(MQTT_STATE_TOPIC, jsonState().c_str());
      } else {
        DynamicJsonDocument resp(128);
        resp["status"] = "error";
        resp["message"] = "IK out of reach";
        String buf; serializeJson(resp, buf);
        webSocket.sendTXT(num, buf);
      }
    } else if (strcmp(cmd, "home") == 0) {
      for (int i=0;i<NUM_JOINTS;i++) currentAngles[i]=90;
      applyAngles(); notifyWebClientsState(); if (mqttClient.connected()) mqttClient.publish(MQTT_STATE_TOPIC, jsonState().c_str());
    }
  }
}

void mqttCallback(char* topic, byte* payload, unsigned int length) {
  StaticJsonDocument<256> doc;
  DeserializationError err = deserializeJson(doc, payload, length);
  if (err) return;
  const char* type = doc["type"] | "";
  if (strcmp(type, "move") == 0) {
    bool changed = false;
    for (int i=0;i<NUM_JOINTS;i++) {
      char key[4]; sprintf(key, "j%d", i+1);
      if (doc.containsKey(key)) {
        currentAngles[i] = constrain((int)doc[key], ANGLE_MIN, ANGLE_MAX);
        changed = true;
      }
    }
    if (changed) { clampAngles(); applyAngles(); notifyWebClientsState(); mqttClient.publish(MQTT_STATE_TOPIC, jsonState().c_str()); }
  } else if (strcmp(type, "ik") == 0) {
    float x = doc["x"]|0.0; float y = doc["y"]|0.0; float z = doc["z"]|0.0; float grip = doc["grip"]|90.0;
    float outAngles[4];
    if (computeIK(x,y,z,outAngles)) {
      currentAngles[0] = constrain((int)round(outAngles[0]), ANGLE_MIN, ANGLE_MAX);
      currentAngles[1] = constrain((int)round(outAngles[1]), ANGLE_MIN, ANGLE_MAX);
      currentAngles[2] = constrain((int)round(outAngles[2]), ANGLE_MIN, ANGLE_MAX);
      currentAngles[3] = constrain((int)round(grip), ANGLE_MIN, ANGLE_MAX);
      clampAngles(); applyAngles(); notifyWebClientsState(); mqttClient.publish(MQTT_STATE_TOPIC, jsonState().c_str());
    } else {
      mqttClient.publish(MQTT_STATE_TOPIC, "{\"status\":\"error\",\"message\":\"ik out of reach\"}");
    }
  } else if (strcmp(type, "home")==0) {
    for (int i=0;i<NUM_JOINTS;i++) currentAngles[i]=90;
    applyAngles(); notifyWebClientsState(); mqttClient.publish(MQTT_STATE_TOPIC, jsonState().c_str());
  }
}

void connectMQTT() {
  if (!WiFi.isConnected()) return;
  mqttClient.setServer(MQTT_SERVER, MQTT_PORT);
  mqttClient.setCallback(mqttCallback);
  while (!mqttClient.connected()) {
    Serial.print("Connecting to MQTT...");
    String clientId = "esp32-robotarm-";
    clientId += String(WiFi.macAddress());
    if (mqttClient.connect(clientId.c_str(), MQTT_USER, MQTT_PASS)) {
      Serial.println("connected");
      mqttClient.subscribe(MQTT_CMD_TOPIC);
      mqttClient.publish(MQTT_AVAILABILITY_TOPIC, "online");
      mqttClient.publish(MQTT_STATE_TOPIC, jsonState().c_str());
    } else {
      Serial.print("failed, rc=");
      Serial.print(mqttClient.state());
      Serial.println(" try again in 3s");
      delay(3000);
    }
  }
}

void connectWiFi() {
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  Serial.print("Connecting to WiFi");
  unsigned long start = millis();
  while (WiFi.status() != WL_CONNECTED) {
    delay(500); Serial.print(".");
    if (millis() - start > 15000) {
      Serial.println("\nWiFi connection timed out. Starting AP mode.");
      WiFi.softAP("RobotArm-Setup");
      Serial.print("AP IP: "); Serial.println(WiFi.softAPIP());
      return;
    }
  }
  Serial.println();
  Serial.print("Connected. IP: ");
  Serial.println(WiFi.localIP());
}

void setup() {
  Serial.begin(115200);
  delay(100);
  for (int i=0;i<NUM_JOINTS;i++) {
    servos[i].setPeriodHertz(50);
    servos[i].attach(SERVO_PIN[i], 500, 2400);
    servos[i].write(currentAngles[i]);
  }
  connectWiFi();
  server.on("/", HTTP_GET, handleRoot);
  server.on("/api/state", HTTP_GET, handleApiState);
  server.on("/move", HTTP_GET, handleMove);
  server.onNotFound(handleNotFound);
  server.begin();
  webSocket.begin();
  webSocket.onEvent(onWebSocketEvent);
  mqttClient.setServer(MQTT_SERVER, MQTT_PORT);
  mqttClient.setCallback(mqttCallback);
  if (WiFi.isConnected()) connectMQTT();
  if (mqttClient.connected()) mqttClient.publish(MQTT_STATE_TOPIC, jsonState().c_str());
  Serial.println("Setup complete");
}

unsigned long lastMqttReconnectAttempt = 0;
unsigned long lastStatePublish = 0;

void loop() {
  server.handleClient();
  webSocket.loop();
  if (WiFi.isConnected()) {
    if (!mqttClient.connected()) {
      unsigned long now = millis();
      if (now - lastMqttReconnectAttempt > 5000) {
        lastMqttReconnectAttempt = now;
        connectMQTT();
      }
    } else {
      mqttClient.loop();
    }
  } else {
    static unsigned long lastWiFiTry = 0;
    unsigned long now = millis();
    if (now - lastWiFiTry > 10000) {
      lastWiFiTry = now;
      connectWiFi();
    }
  }
  if (millis() - lastStatePublish > 5000) {
    lastStatePublish = millis();
    if (mqttClient.connected()) mqttClient.publish(MQTT_STATE_TOPIC, jsonState().c_str());
  }
}
